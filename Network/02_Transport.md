# Transport Layer 

## 통신계층에 대해서 설명해보세요.

- 통신계층은 호스트 간의 논리적 통신을 제공하는 네 번째 계층입니다.

## TCP 연결의 특징에 대해서 설명해보세요.

- TCP 는 연결지향형 프로토콜로 신뢰성 있는 통신을 보장합니다. 따라서 매 통신마다 데이터를 송수신하기 전에 클라이언트와 서버가 연결을 설정해주어야 합니다. 또한 혼잡제어와 흐름제어를 제공한다는 특징도 있습니다.

## 신뢰성 있는 통신이 어떤 의미인가요?

- 송신자가 보내는 데이터가 변형이나 누락없이 수신자에게 도착할 수 있는 통신을 의미합니다.

## 중간에 패킷이 누락되거나 유실되는 경우가 있을텐데?

- TCP는 그런 상황을 감지하고 회복하기 위해서 오류제어, 혼잡제어, 흐름제어를 지원합니다.

## 3-Way Handshaking 을 설명해보세요.

- 3 way handshaking 은 TCP 프로토콜로 연결을 설정하는 과정을 의미합니다. 총 세 단계에 걸쳐 연결을 설정하기 때문에 3 way handshaking 이라고 합니다.
- 먼저 연결설정을 위해 클라이언트가 서버에 `TCP SYN` 요청을 보냅니다.
- 요청을 받은 서버는 `TCP SYN ACK` 로 응답하니다.
- 응답을 받은 클라이언트는 `TCP ACK` 을 다시 요청하고 TCP 연결이 설정됩니다.

## 이때 클라이언트와 서버의 상태는 어떤가요?

- 초기에 클라이언트와 서버는 모두 `CLOSED` 상태에 있습니다.
- 서버는 요청을 받을 준비가 되면 `LISTEN` 상태가 되어 클라이언트의 요청을 기다립니다. 
- 클라이언트는 서버에 요청을 보낸 뒤 TCP SYN ACK 을 기다리며 `SYN-SENT` 상태가 됩니다.
- 서버가 요청을 받은 뒤 TCP SYN ACK 을 보내면 `SYN-RECEIVED` 상태가 되어 클라이언트의 SYN ACK 을 기다립니다.
- TCP SYN ACK 을 받은 클라이언트는 서버와의 연결이 완성되었기 때문에 `ESTABLISHED` 상태로 전환되고 서버로 TCP ACK 을 전송합니다.
- TCP ACK 을 서버가 받게되면 두 클라이언트와 서버의 연결이 완성되었으므로 서버의 상태도 `ESTABLISHED` 상태가 됩니다.

![image](https://user-images.githubusercontent.com/46087477/147844247-f4c88ef1-670c-4d40-bf46-68fa3e53b2ea.png)


## 4-Way Handshaking 을 설명해보세요.

- 4 way handshaking 은 TCP 프로토콜로 설정된 연결을 종료하기 위해 사용됩니다.
- 클라이언트가 서버와의 연결을 끊고자 할 때, 클라이언트는 서버에 `FIN` 패킷을 전송합니다.
- 서버는 `FIN` 요청을 받으면 `ACK` 으로 응답합니다.
- ACK 을 받은 클라이언트는 남은 패킷이 완전히 전달되기까지 일정 시간동안 기다립니다.
- 서버는 마지막 패킷까지 모두 전송한 뒤에 `FIN` 메세지를 전송하여 연결을 종료할 수 있음을 알립니다. 
- 클라이언트는 `ACK` 메세지를 다시 전송하여 서버의 연결 종료를 요청합니다.
- 요청을 받은 서버는 연결을 종료합니다.
- 클라이언트는 `FIN` 메세지보다 나중에 도착하는 패킷을 받기 위해 `MSL(Double Maimum Segment Life)` 시간동안 대기합니다.
- 대기 시간이 끝나고 클라이언트는 연결을 완전히 종료합니다.

## 이때 클라이언트와 서버의 상태는 어떤가요?

- 초기에는 서버와 클라이언트가 연결된 상태에 있으므로 양쪽 모두 `EATABLISEHD` 상태를 가집니다. 
- 클라이언트는 종료를 요청하는 FIN 메세지를 전송하고, 서버의 ACK 메세지를 기다리는 `FIN-WAIT-1` 상태가 됩니다.
- 이때 서버는 FIN 메세지를 받고 ACK 메세지를 전송한 뒤, `CLOSE-WAIT` 상태가 됩니다.
- 서버의 ACK 메세지를 받은 클라이언트는, 서버의 FIN 메세지를 기다리며 `FIN-WAIT-2` 상태가 됩니다.
- 서버는 자신이 가진 패킷을 모두 전송하고 FIN 메세지를 전송한 뒤 `LAST-ACK` 상태가 됩니다. 
- 클라이언트는 FIN 메세지를 받은 뒤, 서버로 ACK 메세지를 보내고 나머지 패킷을 기다리며 `TIME-WAIT` 상태가 됩니다.
- 서버는 클라이언트의 ACK을 받게되면 연결을 종료하기 때문에 `CLOSED` 상태가 됩니다.
- 클라이언트는 일정시간 기다리고 연결을 종료한 뒤 `CLOSED` 상태가 됩니다.

![image](https://user-images.githubusercontent.com/46087477/147844271-bab6ac32-3a44-45bf-898a-83cab5c24f37.png)

## TCP 클라이언트가 서버로부터 FIN 패킷을 받고도 바로 종료되지 않고 기다리는 이유는?

- 실제로 패킷이 도착하는 순서는 서버측에서 전송한 순서대로 도착하지 않을 수 있기 때문에 아직 도착하지 않은 패킷이 도착할 때까지 기다리게 됩니다.

## TCP 클라언트가 TIME-WAIT 상태로 얼마나 기다리는지 아는지? 

- Double Maximum Segment Liftime(MSL)만큼 기다리고 이 시간은 일반적으로 1분~4분입니다.

## 그럼 Maximum Segment Lifetime이 뭔데요?
- MSL은 TCP 세그먼트가 네트워크에 머무를 수 있길 기대하는 최대 시간을 의미합니다.

## TCP 헤더에 Squence Number 필드가 필요한 이유를 설명해보세요.

- TCP는 항상 패킷의 순서를 보장해야합니다. 따라서 쪼개져있는 세그먼트에 번호를 붙여서 각 패킷이 따로 도착한다고 하더라도 순서대로 다시 재조합할 수 있도록 합니다.

## 그럼 Sequence Number 필드랑 Acknowledgement Number 필드의 차이는 뭐예요?

- Acknowledgement Number 는 서버로부터 받아야할 다음 데이터의 Sequence Number를 나타냅니다.

![image](https://user-images.githubusercontent.com/46087477/147844318-1c3fa98c-075f-41de-8fe5-11c440f18ac4.png)


## 혼잡제어와 흐름제어의 차이를 말해보세요.

- 혼잡제어(Congestion Control)는 네트워크에 패킷이 과도하게 들어오는 것을 막습니다. 송신자가 데이터를 보내는 속도와 네트워크가 데이터를 처리하는 속도의 차이가 있어 문제가 발생합니다. 
- 흐름제어(Flow Control)는 송신 호스트의 속도가 수신 호스트의 처리 속도보다 빨라 수신 호스트의 라우터 큐를 초과하게 되는 상황을 제어하는 것을 말합니다.
- 더 간단하게 설명하면 혼잡제어는 네트워크가 혼잡해지지 않도록 하는 것이고, 흐름제어는 두 호스트간의 네트워크 처리 속도를 맞춰주는 것을 의미합니다.

## TCP가 흐름제어를 어떻게 하는지 설명해보세요.

- TCP 는 Stop-and-Wait 방식이나 Sliding Window 방식을 사용하여 흐름제어를 수행합니다.

## Stop-and-Wait에 대해서 더 자세히 설명해보세요.

- `Stop-and-Wait`는 송신자가 자신이 전송한 패킷에 대한 ACK 을 받아야만 다음 패킷을 전송할 수 있도록 하는 방식입니다.

![image](https://user-images.githubusercontent.com/46087477/147844394-016b7f5c-e045-41d7-afac-30989686e5de.png)

## 문제점은 없나요?

- 만약 서버에서 보낸 ACK이 유실되면 클라이언트는 무한히 대기하게 됩니다.
- 또 클라이언트가 보낸 패킷이 유실되면 서버는 ACK을 보내지 않기 때문에 서로 무한히 대기하게 됩니다.

## 어떻게 해결할까요?

- ARQ(Automatic Repeat Request)로 해결합니다.
- 타임아웃, 데이터의 시퀀스 번호, ACK의 시퀀스 번호를 이용합니다.
- 타임아웃은 세그먼트를 보낸 뒤 일정시간동안 ACK을 받지 못하면 중간에 패킷이 유실되었다고 판단하고 같은 세그먼트를 다시 재전송합니다. 
- 시퀀스 번호는 세그먼트에 번호를 번호를 붙이고 서버는 해당 세그먼트를 받아 오류가 없으면 ACK에 전달받은 데이터의 시퀀스 번호 + 1 을 붙여 클라이언트에게 보냅니다.
- 만약 오류가 발생한다면 NACK을 보냅니다.
- 클라이언트는 타임아웃 이내에 ACK이 오면 ACK에 붙은 시퀀스 번호의 세그먼트를 전송하고, NACK이 오거나 세그먼트가 타임아웃까지 오지 않으면 같은 세그먼트를 재전송합니다.

![image](https://user-images.githubusercontent.com/46087477/147844547-821bdfbd-d2eb-4756-a64b-864447c6c7cf.png)


## 이 방식에 문제점은?

- Stop and Wait는 송신자가 반드시 이전 패킷에 대한 ACK을 기다려야하기 때문에 성능이 좋지 않다는 단점이 있습니다.

## 그럼 Sliding Window는?

- `Sliding Window` 방식은 수신측과 송신측에 윈도우라는 버퍼를 두고 알고리즘에 따라 전송할 세그먼트의 번호와 수신할 세그먼트의 수신번호의 영역을 설정하여 한번에 전송할 수 있는 세그먼트의 양을 제한하여 흐름을 제어하는 방식입니다.

## 구체적인 동작 방식을 설명해주세요.

- 현재 윈도우 안에 있는 패킷들을 전송하고, 해당 패킷에 대한 ACK을 받으면 처리한 패킷만큼 윈도우 크기를 줄여줍니다.

![image](https://user-images.githubusercontent.com/46087477/147844764-5277dd5f-bff1-4a6f-ae6c-f11887926bec.png)

## Stop and Wait에 비해 좋은점은?

- 한번에 전송할 수 있는 패킷의 수가 많아집니다.

## Go-Back-N에 대해서 설명해보세요.

- 슬라이딩 윈도우 프로토콜 중 한 종류입니다. 슬라이딩 윈도우 처럼 전송한 패킷에 대한 ACK을 받으면 윈도우를 줄여주는 방식입니다. 
- 송신측은 윈도우 안에 포함된 패킷들을 모두 전송하고, 만약 이미 받은 번호에 대한 ACK을 다시 받으면 무시합니다. 
- 수신측은 송신측이 보내는 패킷들을 순서대로 받고, 만약 순서가 맞지 않게 앞 번호 패킷보다 뒷 번호 패킷을 먼저 받으면 해당 패킷은 버리고 마지막으로 받는데 성공한 패킷의 번호를 ACK으로 응답합니다.
- 수신측은 자신이 전송한 패킷에 대한 ACK을 일정시간동안 받지 못하면 타임아웃을 발생시키고 마지막으로 성공한 패킷의 다음 패킷부터 모두 다시 보냅니다.


![image](https://user-images.githubusercontent.com/46087477/147844890-405c3c19-ad2d-469d-88bc-9752717eca2c.png)

## Go Back N의 문제점은?

- 송신한 패킷이 유실되거나 ACK이 유실되어서 ACK을 받지 못하면 모든 패킷을 다시 재전송하는 문제가 있습니다.

## 어떻게 해결할까요?

- 이런 문제를 해결하기 위해 Selective Repeat 프로토콜이 나왔습니다.
- SR의 수신측은 GBN과 동일하게 윈도우에 있는 패킷들을 
- SR은 수신측이 순서에 맞지 않게 받은 패킷들을 버퍼에 따로 저장해두고 중간에 빠졌던 패킷이 도착하면 이를 조합해서 사용합니다. 
- 따라서 패킷을 버리지 않고 사용하기 때문에 송신측에서는 이미 전달에 성공한 패킷을 다시 전송할 필요가 없어 GBN의 문제점이 해결됩니다.

![image](https://user-images.githubusercontent.com/46087477/147844994-178f5593-010c-40eb-96b6-f9cc2af16ae7.png)

## 그럼 TCP가 혼잡제어는 어떻게 하는지 설명해보세요.

- 각 호스트는 Congestion Window를 가지고 있습니다. 이 윈도우의 크기에 따라서 전송가능한 크기가 결정됩니다. 혼잡제어는 네트워크의 상황을 모니터링하면서 이 혼잡 윈도우의 크기를 늘리거나 줄여서 송신자가 전송한는 패킷의 개수를 조절하는 것입니다.
- 혼잡제어는 크게 `AIMD(Additive Increase Multicative Decrease)` 와 `Slow Start` 를 사용하여 수행합니다. 
- AIMD는 네트워크가 혼잡하지 않아 전송속도를 늘릴 수 있을 때는 1 씩 증가시키고, 혼잡제어를 위해 전송속도를 줄일 때는 반으로 윈도우의 크기를 줄여 전송할 패킷의 개수를 줄여주는 방법입니다.

## 혼잡 윈도우의 크기는 어떻게 결정되나요?

- 혼잡 윈도우의 크키는 네트워크에서 한번에 보낼 수 있는 데이터의 크기인 MSS(Maximum Segment Size)로 결정됩니다. 
- MSS는 세그먼트 크기에서 IP헤더와 옵션, TCP 헤더와 옵션을 제외한 순수한 데이터의 크기를 의미합니다.

## 혼잡이 발생했는지 어떻게 알죠?

- 전송한 패킷에 대한 ACK이 도착하지 않아 Timeout이 발생하면 패킷이 유실되었다고 생각하고 네트워크가 혼잡하다고 추론할 수 있습니다.
- 또 동일한 패킷에 대한 ACK이 중복적으로 3번 발생하면 일반적인 상황이 아니라고 판단해 네트워크의 혼잡으로 판단할 수 있습니다.

## AIMD를 더 자세히 설명해주세요.

- AIMD는 최초에는 혼잡 윈두우의 크기를 1MSS로 설정한뒤 시간이 지남에 따라 네트워크 혼잡이 발생하지 않으면 윈도우의 크기를 1씩 늘리고, 혼잡이 발생하면 윈도우의 크기를 반으로 줄이는 방법입니다.

![image](https://user-images.githubusercontent.com/46087477/147845152-746c425d-0c39-458d-9e4c-2ab3c1937ef3.png)

## AIMD의 문제점은?

- 혼잡 윈도우를 선형적으로 증가시키기 때문에 네트워크 상태가 원활하여 패킷을 많이 보낼 수 있는 상황에서도 그런 상태까지 도달하기까지 시간이 걸린다는 문제가 있습니다.

## Slow Start는 그럼 뭔가요?

- AIMD가 가진 문제를 해결하기 위해서 1MSS로 시작한 혼잡 윈도우 크기를 지수적으로 계속 증가시킵니다.
- 만약 네트워크 혼잡이 감지되면 혼잡 윈도우를 곧바로 1로 줄여주고 다시 지수적으로 증가시킵니다.

![image](https://user-images.githubusercontent.com/46087477/147845207-477f5258-1e66-4e31-b6f4-a9b20f6ceca7.png)


## Tahoe에 대해서 설명해주세요.

- Tahoe는 혼잡제어를 위해 Slow Start와 AIMD를 섞어서 사용합니다.
- Tahoe는 Slow Start를 사용해서 윈도우의 크기를 빠르게 증가시키다가, Slow Start를 사용할 윈도우의 크기에 대한 임계점인 ssthresh를 만나면 AIMD방식을 선택해 선형적으로 윈도우의 크기를 증가시킵니다.
- 만약 타임아웃이나 3 ACK Duplicate가 발생하면 ssthresh는 현재 윈도우의 크기의 절반으로 갱신하고 자신의 혼잡 윈도우으 크기는 Slow Start에 따라 1로 줄여줍니다.
- 한번 혼잡이 발생했던 윈도우 크기에 빠르게 도달하지 않게 하기위해 임계점을 줄여주는 것입니다.

![image](https://user-images.githubusercontent.com/46087477/147845307-af0691eb-d5bd-4268-9580-e05ed1060f4b.png)

## Tahoe의 문제점은?

- Slow Start에 따라 혼잡이 감지되면 윈도우의 크기가 1로 줄어들어 다시 적정크기만큼 커지는데 시간이 오래걸리게됩니다.

## Reno는 알고있나요?

- Reno는 Tahoe에서 3 Ack Duplicate와 타임아웃에 대한 정책을 구분합니다.  
- 3 ACK Duplicate에서는 AIMD 방식으로 윈도우의 크기를 반으로 줄이고, 해당 크기를 새로운 임계점인 ssthresh로 정의합니다.
- 타임아웃이 발생하면 임계점은 변경하지 않고 윈도우 크기만 1로 줄입니다.
- 이렇게 하면 혼잡이 감지된 뒤에 다시 윈도우 크기를 시작할 때 더 빠르게 윈도우 크기를 늘릴 수 있기 때문에 Fast Recovery 방법이라고도 불립니다.

![image](https://user-images.githubusercontent.com/46087477/147845404-d4dbd642-5b60-4419-aaff-a7e3ac90171e.png)


## UDP의 특징에 대해서 설명해보세요.

- UDP는 비 연결형 서비스로 데이터그램 방식으로 데이터를 송수신하는 프로토콜입니다. 신뢰적 통신을 보장하지는 않지만 빠른속도로 데이터를 송수신할 수 있어 스트리밍 같은 빠른 반응이 필요한 서비스에 사용됩니다.

## UDP 헤더에는 어떤 정보들이 들어가나요?

- 수신자와 송신자의 포트번호, 헤더와 데이터의 총합 길이, 오류검사를 위한 체크섬이 포함됩니다.

![image](https://user-images.githubusercontent.com/46087477/147845906-9fd12365-7a3f-475f-bbb8-f451d60c0e72.png)

## UDP의 오류검사는 어떻게 이루어지나요?

- 송신할 때는 체크섬 필드를 제외한 모든 필드의 값을 16비트 단위로 나누어 더해 체크섬에 넣어 보내고, 수신측에서 같은 방법으로 체크섬 필드를 제외한 모든 필드의 값을 더해 패킷에 세그먼트에 기록된 체크섬과 일치하는지 확인합니다.

## SSL 에 대해서 설명해보세요.

- SSL은 Application Layer 와 Transport Layer 사이에서 데이터를 암호화/복호화하여 양 계층에 전달하는 암호화 통신 프로토콜입니다.

## SSL의 통신과정을 설명해보세요.

- SSL 은 기존 TCP 3-way handshaking 과정에 SSL Handshaking 을 추가하여 사용합니다. 
- 클라이언트는 서버에 client hello 메세지를 보냅니다. 이때 랜덤한 데이터를 생성하여 함께 보냅니다.
- 서버는 요청을 받은 뒤 server hello 로 응답하면서 인증서와 암호화 방식, 서버에서 랜덤하게 생성한 데이터를 응답으로 전달합니다.
- 클라이언트는 서버가 보낸 인증서가 CA에 의해 발급된 인증서인지 확인합니다. 유효한 인증서라면 클라이언트는 대칭키를 생성한 뒤 인증서에 포함된 공개키로 대칭키를 암호화하여 서버에 전송합니다. 
- 서버는 자신이 가진 개인키로 암호화된 대칭키를 복호화합니다.
- 이제 양쪽 호스트는 모두 대칭키를 가지게 되었고 이 키를 사용하여 통신시 전달되는 데이터를 암호화하고 복호화합니다.

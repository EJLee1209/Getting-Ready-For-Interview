# Intro

## OSI 7 계층에 대해서 설명해주세요.

- 응용 계층, 표현 계층, 세션 계층, 전송 계층, 네트워크 계층, 데이터 링크 계층, 물리 계층이 있습니다.
- 응용 계층은 사용자와 상호작용하면서 요청을 보내고 응답을 받는 최종 계층입니다.
- 표현 계층은 보낼 데이터를 인코딩하고 받는 데이터는 디코딩하는 계층입니다.
- 세션 계층은 통신을 할 호스트 사이에 세션을 연결하고 통신 방식을 결정하는 계층입니다.
- 전송 계층은 두 호스트 간의 논리적인 연결을 설정하는 계층입니다.
- 네트워크 계층은 통신을 할 경로를 설정하는 계층입니다.
- 데이터 링크 계층은 통신과정의 오류를 감지하고 물리적인 네트워크 사이에 통신을 담당하는 계층입니다.
- 물리 계층은 네트워크 케이블에 전송할 데이터를 전기신호로 전송하는 계층입니다.

## 왜 7개의 계층으로 나누었을까요?

- 통신이 일어나는 과정을 계층별로 관심사를 분리해 쉽게 파악하고, 문제가 생겼을 때는 특정한 계층에만 집중할 수 있게 하기위해서 여러 계층으로 나누었습니다.

# Application Layer

## HTTP가 무엇인가요?

- HTTP는 네트워크 상에서 문서를 전송하기 위한 프로토콜입니다.

## HTTP는 statless 하다는 것이 어떤 의미인지 설명해보세요.

- HTTP 는 stateles protocol로 서버가 클라이언트의 상태정보를 저장하지 않는 것을 의미합니다.

## 근데 우리가 웹사이트를 사용하면 상태가 저장되지 않나요? 로그인 정보 등등

- 상태를 유지하기 위해 쿠키나 세션을 추가적으로 사용합니다.

## 쿠키랑 세션의 차이는 뭐에요?

- 쿠키는 브라우저에 정보를 저장하고 서버에 요청을 할 때마다 쿠키를 읽어 보냅니다.
- 세션은 서버에서 정보를 저장하고 통신을 하는 사용자를 식별하여 정보를 사용합니다.

## HTTP/1.1 에서 업데이트된 주요 기능들에 대해서 설명해보세요.

- HTTP/1.1 에서는 `Keep Alive` 가 기본설정이 되고 `파이프라이닝`이 추가되었습니다. 
- Keep Alive 는 TCP 연결을 특정 시간동안 유지시켜 새로운 요청이 시작될 때 새로운 연결을 설정할 필요없이 사용하던 TCP 연결을 사용하도록 하는 기능입니다. 
- 파이프라이닝은 클라이언트가 요청을 보내고 응답을 받기 전에 다음 요청을 전송할 수 있도록 하는 기능입니다. 

## HTTP/1.1 에서 파이프라이닝을 사용할 때 발생하는 문제는 없을까요?

- 파이프라이닝을 사용하면 `Head Of Line Blocking` 문제가 발생합니다. 
- 서버는 클라이언트로부터 연속된 요청을 파이프라이닝을 통해 받았을 때, 순차적으로 처리하기 때문에 첫번째 요청에 대한 처리가 끝나야 다음 요청을 처리할 수 있습니다. 
- 따라서 만약 첫 요청의 처리시간이 길어지면 쌓여있는 요청들은 첫요청이 끝날때까지 기다려야하는 현상이 발생합니다.

## HTTP/2.0 에서 업데이트된 주요 기능들을 설명해보세요.

- HTTP/2.0 은 응답/요청 메세지를 Plain Text 로 송수신하지 않고 바이너리로 인코딩된 Frame 을 사용합니다. 
- 또한 클라이언트가 요청하지 않았지만 필요로 할 리소스를 송신하는 `Server Push` 도 추가되었습니다. 
- 마지막으로 HTTP/1.1 에서 파이프라이닝의 문제점으로 지적되었던 Head of Line Blocking 문제를 frame 과 stream을 사용하여 Multiplexing 을 지원하는 것으로 해결했습니다. 

![image](https://user-images.githubusercontent.com/46087477/147846132-e440d627-7b8c-4ba7-b862-b8c4a65e96a2.png)


## Multiplexing을 지원하는게 어떤의미죠?

- 하나의 연결 채널을 통해서 여러 메시지를 주고받을 수 있다는 것을 의미합니다. 이제는 HTTP 메시지가 프레임 단위이기 때문에 여러 요청에 대한 응답을 수신측에서 받아도 스트림 번호를 통해 이를 구분할 수 있게 되었습니다.

## HTTP 메서드들과 의미를 설명해보세요.

- HTTP 메세지는 GET, POST, HEAD, PUT, OPTIONS, PATCH, CONNECT, DELETE 가 있습니다.
- `GET` 방식은 서버로부터 리소스를 읽어오기 위해 사용합니다.
- `POST` 방식은 서버에 데이터를 추가하기 위해 사용합니다.
- `HEAD` 방식은 서버에 리소스를 요청하고 응답 body를 제외하고 응답코드와 헤더정보만 응답으로 받기 위해 사용합니다.
- `PUT` 방식은 서버 리소스를 업데이트 하기 위해 사용합니다.
- `OPTIONS` 방식은 클라이언트가 서버가 지원하는 메서드를 확인하기 위해 사용합니다.
- `PATCH` 방식은 서버 리소스의 일부를 업데이트 하기 위해 사용합니다.
- `CONNECT` 방식은 클라이언트가 HTTP 프록시 서버를 통해 서버와 연결을 요청하기 위해 사용합니다.
- `DELETE` 방식은 서버의 리소스를 삭제하기 위해 사용합니다.

## 프록시 서버에 대해서 설명해보세요

- 프록시 서버는 클라이언트와 서버 사이에 징검다리 역할을 합니다. 프록시 서버는 클라이언트가 프록시 서버에 보냈던 요청을 캐싱해두었다가 캐싱된 리소스에 대한 요청을 들어오면 실제 서버로 요청을 보내지 않고 자신이 가진 리소스를 응답해줍니다. 또한 클라이언트와 서버가 직접 통신하지 않고 경유하기 때문에 보안에도 이점이 있습니다.

## 그럼 프록시 서버는 캐시 정보가 최신데이터인지 어떻게 확인할까요?

- 프록시 서버는 실제 서버에 조건부 GET을 사용해서 마지막으로 수정된 시간을 확인합니다. 프록시 서버는 본 서버에 `If-Modified-Since` 헤더에 자신이 가진 리소스의 수정시간을 포함시켜 요청을 보냅니다. 
- 본 서버는 이 헤더에 있는 시간과 자신이 가진 리소스의 시간을 확인하여 시간이 같다면 응답 상태 메세지만 송신하고, 다르다면 최신 리소스를 담아 보냅니다. 
- 프록시 서버는 이 응답을 확인하고 자신의 리소스를 클라이언트로 송신하거나, 새로 받은 리소스를 업데이트 한 뒤에 클라이언트로 전송합니다.

## HTTP 상태코드를 앞번호 기준으로 분류해서 설명해보세요.

- 100번대 코드는 `조건부 응답` 코드로 서버가 요청을 처리했고 추가적인 작업을 수행한다는 것을 클라이언트에게 알립니다.
- 200번대 코드는 `성공` 코드로 클라이언트의 요청을 성공적으로 처리했다는 것을 알립니다.
- 300번대 코드는 `리다이렉트` 코드로 클라이언트가 응답을 받고 추가적인 동작을 수행해야한다는 것을 알립니다.
- 400번대 코드는 `요청오류` 코드로 클라이언트가 서버에 보낸 요청이 잘못되었음을 알립니다.
- 500번대 코드는 `서버오류` 코드로 서버 측 문제로 인해 요청을 처리하지 못했음을 알립니다.

## HTTPS와의 차이는?

- HTTPS는 SSL을 통해 서버와 클라이언트 사이에 주고받는 데이터를 암호화합니다.

## SSL이 추가되는 과정을 설명해주세요.

- 클라이언트는 서버에 client hello 메세지를 보냅니다. 이때 랜덤한 데이터를 생성하여 함께 보냅니다.
- 서버는 요청을 받은 뒤 server hello 로 응답하면서 인증서와 암호화 방식, 서버에서 랜덤하게 생성한 데이터를 응답으로 전달합니다.
- 클라이언트는 서버가 보낸 인증서가 CA에 의해 발급된 인증서인지 확인합니다. 유효한 인증서라면 클라이언트는 주고받은 랜덤한 데이터로 대칭키를 생성한 뒤 인증서에 포함된 공개키로 대칭키를 암호화하여 서버에 전송합니다. 이제 이 대칭키는 서버에서만 복호화가 가능합니다.
- 서버는 자신이 가진 개인키로 암호화된 대칭키를 복호화합니다. 
- 이제 양쪽 호스트는 모두 대칭키를 가지게 되었고 이 키를 사용하여 통신시 전달되는 데이터를 암호화하고 복호화합니다.

![image](https://user-images.githubusercontent.com/46087477/147846527-e2e214a9-479b-4e44-b048-a6e882fecb99.png)

## 공개키와 비밀키 (비대칭키 암호화)는 뭔가요?

- 공개키는 서버에서 클라이언트에게 발급해 누구나 받을 수 있는 키를 의미합니다. 클라이언트는 데이터를 이 공개키로 암호화하고, 서버는 자신만 알고있는 비밀키로 복호화합니다. 
- 공개키로 암호화된 데이터는 비밀키로만 복호화할 수 있습니다.

## REST가 어떤 의미인지 아시나요?

- REST는 자원, 행위, 표현을 통해 자원과 자원에 대한 동작을 정의하는 것을 의미합니다.

## 네트워크에서는 자원, 행위, 표현을 어떻게 정의하나요?
- 자원은 자원의 위치인 URI로 정의하고, 행위는 HTTP Method로, 표현은 JSON이나 XML같은 형식으로 정의합니다.

## URL과 URI의 차이는?

- URL은 네트워크에서 리소스가 어디에 위치하는지 나타내는 주소를 의미하고, URL을 포함하는 개념으로 자원을 식별하기 위한 식별자입니다.

## REST API에서 사용되는 HTTP Method들의 의미를 말해보세요.

- GET: 자원을 읽기 위해 사용합니다.
- DELETE: 자원을 삭제하기 위해 사용합니다.
- POST: 자원을 새로 추가하기 위해 사용합니다.
- PUT: 이미 존재하는 자원을 변경하기 위해 사용합니다.
- PATCH: 자원의 일부를 변경하기 위해 사용합니다.

## 브라우저에 웹 URL을 입력했을 때 DNS의 동작과정을 설명해보세요.

1. 먼저 입력된 도메인네임이 로컬의 `호스트 파일`과 `DNS 캐시`에 등록되어 있는지 확인합니다. 있다면 반환된 ip 주소를 사용하여 접속합니다.
2. 없다면 `로컬 네임서버`에 도메인 네임을 포함한 쿼리를 전송합니다. 
3. 로컬 네임서버는 `루트 네임서버`에 도메인 네임을 포함하는 쿼리를 전송하여 해당 도메인에 대한 TLD 서버의 정보를 반환합니다. 예를 들어 요청된 도메인네임이 www.example.com 이라면, .com 도메인 네임을 관리하는 서버의 정보를 반환합니다.
4. 정보를 받은 로컬 네임서버는 `TLD 서버`에 도메인 네임을 포함한 쿼리를 전송합니다. TLD 서버는 해당 도메인네임에 대한 책임 DNS 서버의 ip주소를 반환합니다. 
5. 로컬 네임서버는 전달받은 `책임 DNS 서버`의 ip 주소로 도메인 네임을 포함한 쿼리를 다시 전송합니다.
6. 책임 DNS 서버는 해당 도메인네임에 대한 ip 주소를 로컬 네임서버에게 반환합니다.
7. 로컬 네임서버는 이제 도메인네임에 대한 ip 주소를 알아내었습니다. 따라서 클라이언트에게 해당 ip 주소를 반환합니다.
8. 클라이언트는 전달받은 도메인네임에 대한 ip 주소로 필요한 요청을 보냅니다.

![image](https://user-images.githubusercontent.com/46087477/147846462-4588e0cc-0c91-4255-b2ba-02b6f120b3b8.png)


## 이렇게 하면 로컬 네임서버가 매번 각 서버에 쿼리를 보내야할 것 같은데 맞아요? 다른 방법은 없을까요?

- 네 맞습니다. 다른 방법으로는 재귀적으로 쿼리를 요청하는 방법이 있습니다. `재귀적 쿼리요청`은 로컬 네임서버가 아니라 루트, TLD, 책임 DNS 서버가 자신의 하위 계층에 요청을 보내 상위 계층으로 응답을 전달하는 방식으로 동작합니다. 따라서 로컬 DNS 서버는 한번의 쿼리만 보내게되고 이 쿼리가 각 계층의 DNS 서버에 재귀적으로 전달되고 반환됩니다.

## DHCP는 어떤 목적으로 사용되는지 설명해보세요.

- DHCP 는 네트워크 어플리케이션에 동적으로 IP주소를 할당하는 역할을 합니다. DHCP 서버는 각 단말기에서 요청을 받았을 때 임시적으로 사용할 IP주소를 할당해주고 사용이 끝나면 해당 ip주소를 다시 돌려받습니다.

## 단말기가 IP주소를 할당받는 과정을 설명해보세요.

- 단말기는 네 단계에 걸쳐서 ip주소를 할당받습니다.
- 먼저 단말기가 `DHCP Discover` 메세지를 브로드캐스트로 전송합니다.
- 요청을 인지한 DHCP 서버는 단말기로 `DHCP Offer` 메세지를 보냅니다. 이 메세지 안에는 요청을 보낸 단말기의 정보와 할당할 IP 주소, 사용 가능한 시간 등이 포함됩니다.
- 단말기는 DHCP로부터 네트워크 정보를 받습니다. 그리고 `DHCP Request` 메세지를 보내서 해당 IP 주소에 대한 획득을 요청합니다.
- DHCP 서버는 요청을 받고 해당 단말기가 네트워크 정보를 사용하도록 확정합니다. 이를 위해 네트워크 정보다 담겨있는 `DHCP-ACK` 메세지를 전송합니다.

## 표현 계층에서는 어떤 일을 하는지 설명해주세요.

- 표현 계층은 전송할 데이터를 암호화하고, 수신한 데이터를 복호화하는 작업을 합니다. 인코딩이나 디코딩이 이 계층에서 이루어집니다.

## 세션 계층에서는 어떤 일을 하는지 설명해주세요.

- 세션 계층은 두 호스트의 세션을 연결하고 전송 모드를 결정하는 계층입니다.

## 전송 모드가 어떤게 있나요?

- 전이중방식과 반이중방식이 있습니다.
- 전이중방식은 두 호스트가 수신과 송신을 동시에 할 수 있는 방식입니다.
- 반이중방식은 한번에 수신과 송신 중 하나만 할 수 있는 방식입니다.

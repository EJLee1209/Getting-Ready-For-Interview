# 스택 & 큐

## 스택과 큐의 차이점을 설명해보세요

- 스택은 LIFO 성격을 띄는 자료구조로 가장 마지막에 넣은 원소를 가장 먼저 꺼냅니다. 반면에 큐는 FIFO 성격의 자료구조로 먼저 들어간 원소를 가장 먼저 꺼냅니다.

## 배열과 링크드 리스트 중 하나로 스택을 구현한다면 어떤 걸 선택할래요?

- 스택은 마지막 원소만 삭제해주면 됩니다. 만약 단방향 링크드 리스트를 사용한다면 마지막 바로 이전 노드까지 탐색을 진행한 뒤에 연결을 끊어줘야 합니다. 따라서 O(N)의 시간복잡도가 요구됩니다. 배열을 사용하면 배열의 길이만 1 줄여주면 되기 떄문에 O(1)의 시간복잡도가 요구됩니다. 따라서 배열을 사용하는 것이 더 효율적입니다. 

## 원형 큐는 시작과 끝 인덱스 관리를 어떻게 하는지 설명해보세요.

- 원형 큐는 front 와 rear 를 가르키는 포인터를 사용합니다. 삽입할 때는 항상 rear 포인터의 위치에 값을 넣고 삭제할때는 front 가 가르키는 위치의 다음 값을 삭제합니다. 두 포인터 모두 같은 인덱스에서 시작하고 rear 는 삽입이 될떄마다 한칸 씩 이동, front 는 삭제가 될때마다 한칸씩 이동합니다. 이 때문에 front 는 항상 비어있는 인덱스를 가르킵니다. 만약 rear의 인덱스가 front 의 인덱스와 같다면 원형 큐가 가득 찬 것으로 판단합니다. 

## 그럼 front 인덱스의 값은 왜 비워두나요?

- 원형큐는 rear + 1 을 큐의 전체 크기로 모듈로 연산한 값을 front 값과 비교합니다. 이 연산은 큐가 공백상태인지, 포화상태인지 구분하기 위한 용도로 사용됩니다. 따라서 rear 가 front 의 바로 이전 인덱스에 있을 경우 rear == front 가 만족되기 때문에 front 에는 값이 채워질 수 없습니다.

## 스택으로 큐를 만드는 방법을 말해보세요.

- 스택 두 개를 사용하면 큐를 구현할 수 있습니다. 한 개의 큐는 데이터를 쌓는 용도로 사용하고 다른 하나는 데이터를 삭제하는 용도로 사용합니다. push 연산이 들어올 때는 첫번째 큐에 데이터를 모두 넣습니다. 그리고 pop 연산이 수행되면 첫번째 스택에서 데이터를 순서대로 pop 해 모두 다른 한 쪽의 스택으로 넣어주고 마지막으로 들어간 데이터를 다시 pop 해주면 가장 첫번째로 넣은 데이터를 꺼낼 수 있습니다. 

## 우선순위 큐에 대해서 설명해보세요.

- 우선순위 큐는 힙 자료구조를 사용해서 원소들간의 우선순위에 따라 가장 우선순위가 높은 원소를 꺼내는 자료구조입니다. 새로운 데이터를 삽입하거나 삭제할 때마다 힙의 완전이진트리를 재배열해주어야 하기 때문에 삽입과 삭제에 O(logN)의 시간복잡도가 요구됩니다. 

## 힙 말고 다른 방법으로는 우선순위 큐를 만들 수 없을까요?

- 링크드 리스트로도 우선순위 큐를 만들 수 있습니다. 이때 삽입은 O(N), 삭제는 O(1) 의 시간복잡도를 가집니다. 즉, 데이터의 개수가 많아질 수록 효율이 떨어집니다.

# 트랜잭션 

## 트랜잭션이 무엇인지 말해보세요.

트랜잭션은 데이터베이스의 상태를 변화시키는 작업의 단위입니다.

## 트랜잭션 보호가 왜 필요한지 말해보세요.

- 트랜잭션은 다수의 사용자가 데이터베이스의 데이터에 접근할 때 데이터의 무결성을 보장하기 위해서 사용합니다.

## 트랜잭션의 성질은 어떤게 있어요?

- 트랜잭션은 네 가지 성질을 가져야합니다. (ACID)
- 먼저, `원자성`은 트랜잭션에 관련된 작업은 모두 다 실행되거나 모두 다 실행되지 않도록 보장되어야하는 것을 의미합니다.
- `일관성`은 트랜잭션이 완료되었을 때, 데이터베이스의 데이터가 일관적인 상태를 유지하도록 해야하는 것을 의미합니다.
- `격리성`은 어떤 트랜잭션이 수행될 때 다른 트랜잭션이 간섭할 수 없게 해야한다는 것을 의미합니다.
- `지속성`은 한번 성공한 트랜잭션은 데이터베이스에 영구적으로 반영되어야 한다는 것을 의미합니다.

## 그럼 원자성을 보장하는 방법에 대해서 설명해보세요.

- 트랜잭션의 원자성을 보장하기 위해서 `Commit` 과 `Rollback` 을 사용합니다. Commit은 트렌잭션의 작업이 정상적으로 종료되었고 데이터베이스에 적용되었음을 확정합니다. Rollback은 현재까지 진행중이던 트랜잭션 작업을 취소하고 트랜잭션이 시작되기 전 상태로 데이터베이스를 되돌립니다. 

## 일관성은 그럼 어떻게 보장해야겠어요?

- 일관성은 `Trigger`를 통해 어떤 작업이 수행될 때 연쇄적으로 다른 작업을 수행하도록 할 수 있습니다. 예를 들어 한 테이블의 튜플을 삭제한다고 했을 때, 외래키에 의해 연결된 테이블이 있다면 해당 테이블의 튜플도 함께 삭제해주는 작업을 Trigger로 지정할 수 있습니다.

## 격리성이 보장되지 않아 발생하는 이슈를 설명해보세요.

- `Phantom Read`, `Nonrepeatable Read`, `Dirty Read` 문제가 있습니다. 
- Phantom Read 는 한 트랜잭션 안에서 두 번의 읽기 연산이 있을 때, 처음 데이터를 읽은 후 다른 트랜잭션이 새로운 튜플을 데이터베이스에 삽입시켜 한번 더 데이터를 읽을 때 이전에는 없었던 데이터가 새로 생기는 현상을 의미합니다.
- Non-Repeatable Read는 어떤 트랜잭션이 데이터를 두 번 조회할 때 처음 조회한 직후에 다른 트랜잭션이 간섭하여 해당 데이터의 값을 업데이트하게 되면, 다음 조회에는 처음과 다른 데이터 값이 조회되는 현상을 의미합니다.
- Dirty Read 는 어떤 트랜잭션이 아직 Commit을 하지 않은 상황에서 데이터를 수정하고 다른 트랜잭션이 수정된 데이터를 읽었을 때, 앞선 트랜잭션이 rollback 된다면 데이터베이스에 더 이상 존재하지 않는 데이터를 조회하게 되는 현상을 의미합니다.

## 트랜잭션 격리 수준에 대해서 설명해보세요.

- Level 0 부터 Level 3 까지 있습니다.
- Level 0는 `Read Uncommited` 로 모든 트랜잭션이 제한없이 데이터에 접근할 수 있게하는 격리수준입니다.
- Level 1은 `Read Committed` 로 커밋이 완료된 데이터만 읽도록 합니다. 
- Level 2은 `Repeatable Read` 로 한 트랜잭션 안에서 여러번 테이블을 조회해도 같은 테이블을 얻을 수 있게합니다. 이를 위해 해당 트랜잭션이 시작되기 전에 완료된 커밋을 기준으로 데이터를 조회합니다. 
- Level 3은 `Serializable` 로 여러 트랜잭션이 병렬적으로 수행되는 것을 허용하지 않습니다.

## 공유 Lock 과 베타 Lock 에 대해서 설명해보세요.

- 공유 Lock 은 데이터를 읽을 때 사용하는 Lock 이고 베타 Lock 은 데이터를 변경할 때 사용하는 Lock 입니다. 공유 Lock 으로 인해서 읽기연산은 여러 트랜잭션이 한번에 사용할 수 있습니다. 그리고 베타 Lock 으로 인해 해당 Lock 이 해제될 때까지 다른 트랜잭션이 데이터를 변경하지 못하게 할 수 있습니다.

## Lock 을 사용했을 때 단점은 없을까요?

- Locking 이 과도하게 사용되면 동시성 문제는 해결되지만 처리시간이 길어진다는 단점이 있습니다.

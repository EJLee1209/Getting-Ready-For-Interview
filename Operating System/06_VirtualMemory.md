# 메모리 관리, 가상메모리

## MMU 가 뭔지 설명해보세요.

- MMU 는 CPU 와 메모리 사이에서 주소의 영역을 설정하는 역할을 합니다. MMU 내부에는 재배치 레지스터가 존재해서 CPU가 요구하는 메모리의 위치와 실제 메모리상의 프로그램의 위치를 맞춰줍니다. 즉, 논리적 주소를 물리적 주소로 변환하는 작업을 합니다.

## Swapping 은 무엇인가요?

- 스와핑은 현재 실행 중이지 않은 메모리에 올라온 프로세스를 메모리 공간을 효율적으로 사용하기 위해 디스크에 임시로 저장하고 필요할 때 다시 불러오는 방법입니다.

## Swapping 기법에 문제점은?

- 임시 저장을 디스크에 하기 때문에 스왑의 속도가 오래걸립니다. 따라서 실제로 사용할 때는 전체 프로세스를 스와핑하는 것이 아니라 프로세스의 일부인 페이지만 스왑하거나 디스크내의 파일시스템과 분리된 스왑공간을 만드는 방식으로 구현합니다.

## 연속 메모리 할당 방법을 말해보세요.

- 최초 적합, 최적 적합, 최악 적합으로 세 가지 방법이 있습니다.
- 최초 적합은 메모리의 시작이나 끝지점부터 탐색하면서 요청받은 프로세스를 할당할 수 있는 공간이 발견되면 곧바로 프로세스를 할당하는 방법입니다.
- 최적 적합은 전체 메모리에 남은 공간을 다 확인해보고 요청받은 프로세스를 할당할 수 있는 가장 작은 공간에 프로세스를 할당하는 방법입니다.
- 최악 적합은 전체 메모리에 남은 공간을 다 확인해보고 요청받은 프로세스를 할당할 수 있는 가장 큰 공간에 프로세스를 할당하는 방법입니다.

## 메모리 단편화에 대해서 설명해보세요.

- 메모리 단편화는 내부 단편화와 외부 단편화 두 종류가 있습니다.
- 외부 단편화는 프로세스를 연속 메모리 할당할 때, 흩어진 빈 공간을 합치면 프로세스를 로드할 수 있는 만큼의 여유공간이 있지만 각각의 빈 공간들이 요청받은 프로세스를 할당할 수 있는 크기를 가지지 못해 프로세스를 로드할 수 없는 상태를 의미합니다. 
- 내부 단편화는 프로세스를 동일한 크기의 페이지로 분할 할 때, 페이지를 모두 다 사용하지 않고 마지막 페이지의 일부만을 사용하여 페이지 내부에 빈 공간이 남게되는 상태를 의미합니다. 

## 페이지 테이블에 대해서 설명해보세요.

- 페이지 테이블은 한 프로세스에 대한 논리 주소와 물리 주소를 맵핑한 정보를 가진 테이블입니다. 페이지 테이블은 메인 메모리에 저장되고 각 프로세스들은 `PTBR (Page Table Base Register)` 를 사용해서 페이지 테이블의 포인터를 저장합니다. 따라서 프로세스가 변경될 때는 페이지 테이블을 교체하는 것이 아니라 포인터의 주소만 바꿔서 오버헤드를 최소화합니다.

## TLB 를 왜 쓰고 어떻게 쓰는지 알아요?

- 페이지 테이블의 관점에서 CPU가 요청하는 주소가 실제 페이지까지 도달하기 위해서는 메모리를 두 번 읽어야 합니다. 먼저 레지스터에 저장된 페이지 테이블 포인터를 읽어 메인 메모리에 있는 페이지 테이블을 읽고, 페이지 테이블에 맵핑된 물리주소에 접근해 값을 가져올 때 한 번 더 메모리를 읽게 됩니다. 이때 발생하는 지연시간을 최소화하기 위해서 TLB를 사용합니다. 
- CPU 요청하는 주소를 찾기위해 바로 페이지 테이블에 접근하지 않고 TLB에 해당 논리주소에 대한 맵핑 주소가 있는지 확인합니다. 만약 맵핑정보가 존재한다면 페이지 테이블을 거치지 않고 곧바로 맵핑된 물리 주소에 접근합니다. 만약 정보가 없다면 페이지 테이블을 읽어 물리주소를 확인한 뒤 작업을 수행합니다.

## 공유페이지에 대해서 말해보세요.

- 공유페이지는 똑같은 코드영역을 사용하는 다수의 프로세스가 있을 때 하나의 페이지만 유지하고 각 프로세스의 페이지 테이블이 해당 페이지를 가르키게 하는 기법입니다. 이를 통해 여러 프로세스가 중복으로 사용하는 페이지를 하나만 유지하여 메모리 공간을 절약할 수 있습니다. 

## 요구 페이징에 대해서 말해보세요.

- 요구 페이징은 프로세스의 페이지를 모두 메모리에 로드해서 사용하는 것이 아니라 당장 사용할 페이지만 로드하여 사용하는 방법입니다. 요구페이징은 페이지 테이블의 엔트리에 `valid bit` 를 추가하는 것으로 구현합니다. 만약 CPU가 접근하려는 페이지가 메모리에 없다면 `invalid bit` 를 표시하고 메모리에 존재한다면 `valid bit` 로 표시합니다.

## 페이지 폴트가 일어났을 때 어떤 일이 일어나는지 설명해보세요.

- CPU가 요청한 논리주소가 페이지 테이블 상에 invalid 비트로 설정되어 있다면 페이지 테이블이 CPU로 인터럽트를 보냅니다. 인터럽트를 받은 CPU는 운영체제에게 Page Fault Routine 을 요구합니다. 운영체제는 backing store 혹은 스왑 공간에서 CPU 가 원하는 페이지를 메모리로 가져옵니다. 그리고 페이지 테이블의 valid bit 를 `valid` 로 바꿔줍니다.

## 지역성의 원리 알아요?

- 지역성의 원리는 시간적 지역성과 공간적 지역성이 있습니다. 시간적 지역성은 최근에 참조한 메모리주소를 다시 참조할 가능성이 높다는 것이고, 공간적 지역성은 어떤 메모리 주소를 참조했을 때 다음에 참조할 메모리는 해당 주소 근처에 있을 확률이 높다는 것을 의미합니다.

## 페이지 교체 알고리즘에는 어떤게 있어요?

- 가장 먼저 메모리에 올라왔던 페이지를 디스크로 내려보내는 FIFO 알고리즘이 있습니다.
- 현재 메모리에 있는 프로세스 중 가장 오랫동안 사용되지 않을 페이지를 선택하는 OPT 알고리즘이 있지만 SJF 스케줄링 알고리즘과 마찬가지로 구현이 불가능합니다.
- 일정 주기동안 참조횟수가 가장 적은 페이지를 선택하는 LFU 알고리즘이 있습니다.
- 마지막으로 가장 오랫동안 참조되지 않은 페이지를 선택하는 LRU 알고리즘이 있습니다.
